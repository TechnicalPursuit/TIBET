//  ========================================================================
/**
 * @copyright Copyright (C) 1999 Technical Pursuit Inc. (TPI) All Rights
 *     Reserved. Patents Pending, Technical Pursuit Inc. Licensed under the
 *     OSI-approved Reciprocal Public License (RPL) Version 1.5. See the RPL
 *     for your rights and responsibilities. Contact TPI to purchase optional
 *     privacy waivers if you must keep your TIBET-based source code private.
 */
//  ------------------------------------------------------------------------

/**
 * @type {TP.tsh.eval}
 * @summary Provides support for the TIBET Shell (TSH) during command
 *     processing. These tags are typically not entered manually, they're
 *     normally generated by the TP.tsh.script tag during processing which
 *     focuses on the conversion of script source into a structured form that
 *     can be executed effectively.
 */

/* eslint-disable new-cap, no-unused-vars */
/* globals $INPUT:true, $INDEX:true, $_:true */
/* eslint-enable no-unused-vars */

//  ------------------------------------------------------------------------

TP.tag.ActionTag.defineSubtype('tsh:eval');

TP.tsh.eval.addTraits(TP.tsh.Element);

//  ------------------------------------------------------------------------
//  Type Attributes
//  ------------------------------------------------------------------------

//  A list of operators which are specific to runtime TSH processing. NOTE
//  that operators which desugar to XML tags are not handled here, they are
//  processed by the tsh:script tag during XML desugaring.
TP.tsh.eval.Type.defineAttribute('$tshOperators', TP.ac('^'));

//  The initial key set that the context has before we populate slots onto it,
//  either via the captured scope object or eval()ing code.
TP.tsh.eval.Type.defineAttribute('$originalContextKeySet');

//  ------------------------------------------------------------------------
//  Type Methods
//  ------------------------------------------------------------------------

TP.tsh.eval.Type.defineMethod('$desugarTSH',
function(aString, aShell, aRequest, asTokens) {

    /**
     * @method $desugarTSH
     * @summary Processes the string for TSH-specific sugars such as regex
     *     history replacements, aliases, command substitutions, variable
     *     substitutions, etc. and returns the result.
     * @param {String} aString The source string to tokenize.
     * @param {TP.shell.Shell} aShell The shell instance.
     * @param {TP.sig.Request} aRequest The shell request.
     * @param {Boolean} asTokens True to return the token array.
     * @returns {String|String[]} A desugared string or token list.
     */

    //  standard "special variables" we're willing to expose to scripts
    var $LASTREQ,
        $REQUEST,
        $NODE,
        $SHELL,
        $CONTEXT,
        $SCRIPT,

        str,
        arr,
        len,
        i,
        token,
        value,
        result,
        alias,
        next,
        offset,
        j,
        last,
        msg,

        inFunction,
        brackets,
        previous,
        command,
        parts,
        histMatcher,
        req,
        rewrites,
        result2,
        identValue;

    str = aString;

    //  use the condense routine to tokenize our content for runtime parse
    //  but explicitly turn off whitespace removal.
    arr = TP.$condenseJS(
                    str, false, false,
                    //  All of the JS operators *and* the TSH operators
                    TP.tsh.script.$tshAndJSOperators,
                    true, true, true);

    len = arr.length;
    i = 0;

    if (TP.notValid(token = arr[i])) {
        return str;
    }

    //  initialize our function nesting control vars
    inFunction = false;
    brackets = 0;

    //  set up our output buffer
    result = TP.ac();

    rewrites = TP.ac();

    //  the initial token can be an alias, a history regex substitution, or
    //  an escape for aliasing, etc. we have to watch for them before we
    //  begin the main token processing loop.
    switch (token.value) {
        case '\\':
            //  leading escape means don't bother looking up alias
            //  translation for what follows, but strip the escape itself.
            i += 1;
            break;

        case '^':

            //  regular expression-based history substitution relative to
            //  the previous command's fully-expanded text content
            previous = aShell.getHistory().at(-2);
            if (TP.isValid(previous)) {
                command = previous.at('cmd');

                //  form is ^old^new^flags where flags are optional
                parts = str.split('^');
                histMatcher = TP.rc(parts.at(1),
                                    TP.ifInvalid(parts.at(3), ''));

                if (TP.notValid(histMatcher)) {
                    msg = TP.join(
                            TP.sc('Invalid history regexp substitution: '),
                            parts.at(1),
                            ' ',
                            TP.ifInvalid(parts.at(3), ''));

                    aRequest.fail(new Error(msg));

                    return;
                }

                str = command.replace(histMatcher, parts.at(2));

                //  tricky thing here is that the rewrite might well have
                //  changed then entire nature of the prior command's text
                //  and either one might require asynchronous processing. As
                //  a result we effectively have to construct a new request
                //  and join it to the current one so we don't complete
                //  until the newly generated command text has been
                //  processed.
                req = TP.sig.ShellRequest.construct(
                        TP.hc('cmd', str,
                                'cmdAllowSubs', aRequest.at('cmdAllowSubs'),
                                'cmdAsIs', aRequest.at('cmdAsIs'),
                                'cmdExecute', true,
                                'cmdHistory', aRequest.at('cmdHistory'),
                                'cmdBuildGUI', aRequest.at('cmdBuildGUI'),
                                'cmdLiteral', aRequest.at('cmdLiteral'),
                                'cmdPeer', aRequest,
                                'cmdPhases', aRequest.at('cmdPhases'),
                                'cmdRecycle', aRequest.at('cmdRecycle'),
                                'cmdShell', aRequest.at('cmdShell'),
                                'cmdSilent', aRequest.at('cmdSilent')
                        ));

                req.defineMethod(
                    'cancel',
                    function(aFaultString, aFaultCode, aFaultInfo) {

                        var info,
                            subrequests;

                        info = TP.hc(aFaultInfo);
                        if (TP.isValid(subrequests = info.at('subrequests'))) {
                            subrequests.push(req);
                        } else {
                            subrequests = TP.ac(req);
                            info.atPut('subrequests', subrequests);
                        }

                        return aRequest.cancel(
                                aFaultString ||
                                TP.sc('History request cancelled.'),
                            TP.ifInvalid(
                                    aFaultCode,
                                    TP.FAILED),
                            info);
                    });

                req.defineMethod(
                    'complete',
                    function(aResult) {

                        if (arguments.length > 0) {
                            return aRequest.complete(aResult);
                        } else {
                            return aRequest.complete();
                        }
                    });

                req.defineMethod(
                    'fail',
                    function(aFaultString, aFaultCode, aFaultInfo) {

                        var info,
                            subrequests;

                        info = TP.hc(aFaultInfo);
                        if (TP.isValid(subrequests = info.at('subrequests'))) {
                            subrequests.push(req);
                        } else {
                            subrequests = TP.ac(req);
                            info.atPut('subrequests', subrequests);
                        }

                        return aRequest.fail(
                            new Error(
                                aFaultString ||
                                TP.sc('History request failed.')),
                            TP.ifInvalid(
                                    aFaultCode,
                                    TP.FAILED),
                            info);
                    });

                aShell[TP.composeHandlerName('ShellRequest')](req);

                return;
            } else {
                msg = TP.sc('No previous command to edit.');
                aRequest.fail(new Error(msg));

                return;
            }

        case 'function':

            inFunction = true;
            result.push(token.value);
            i += 1;

            break;

        default:

            if (TP.$is_identifier(token.name)) {
                if (TP.isValid(aShell)) {
                    //  might be an alias, so we have to check for that
                    alias = aShell.getAlias(token.value);
                }

                //  if there was an alias then we have to re-submit for
                //  processing since the alias could reference new tags or
                //  other content the tsh_cmd tag can't process itself.
                if (alias !== token.value) {
                    //  before we submit as a "new request" we have to
                    //  process any local variable interpolations in the
                    //  alias such as ARGV or named argument references.
                    str = this.$interpolateAlias(alias, arr.slice(1));
                    str = this.$desugarTSH(str, aShell, aRequest, asTokens);

                    //  if the desugaring failed the request we're already
                    //  done...something like `blah` exploded or a ${blah}
                    //  failed to resolve etc.
                    if (aRequest.didComplete()) {
                        return;
                    }

                    req = TP.sig.ShellRequest.construct(
                        TP.hc('cmd', str,
                                'cmdAllowSubs', aRequest.at('cmdAllowSubs'),
                                'cmdAsIs', aRequest.at('cmdAsIs'),
                                'cmdExecute', true,
                                'cmdHistory', aRequest.at('cmdHistory'),
                                'cmdBuildGUI', aRequest.at('cmdBuildGUI'),
                                'cmdLiteral', aRequest.at('cmdLiteral'),
                                'cmdPeer', aRequest,
                                'cmdPhases', aRequest.at('cmdPhases'),
                                'cmdShell', aRequest.at('cmdShell'),
                                'cmdRecycle', aRequest.at('cmdRecycle'),
                                'cmdSilent', aRequest.at('cmdSilent')
                        ));

                    req.defineMethod(
                        'cancel',
                        function(aFaultString, aFaultCode, aFaultInfo) {

                            var info,
                                subrequests;

                            info = TP.hc(aFaultInfo);
                            if (TP.isValid(subrequests = info.at('subrequests'))) {
                                subrequests.push(req);
                            } else {
                                subrequests = TP.ac(req);
                                info.atPut('subrequests', subrequests);
                            }

                            return aRequest.cancel(
                                    aFaultString ||
                                    TP.sc('Aliased request cancelled.'),
                                TP.ifInvalid(
                                    aFaultCode,
                                    TP.FAILED),
                                info);
                        });

                    req.defineMethod(
                        'complete',
                        function(aResult) {

                            if (arguments.length > 0) {
                                return aRequest.complete(aResult);
                            } else {
                                return aRequest.complete();
                            }
                        });

                    req.defineMethod(
                        'fail',
                        function(aFaultString, aFaultCode, aFaultInfo) {

                            var info,
                                subrequests;

                            info = TP.hc(aFaultInfo);
                            if (TP.isValid(subrequests = info.at('subrequests'))) {
                                subrequests.push(req);
                            } else {
                                subrequests = TP.ac(req);
                                info.atPut('subrequests', subrequests);
                            }

                            return aRequest.fail(
                                new Error(
                                    aFaultString ||
                                    'Aliased request failed: ' +
                                        this.at('cmd')),
                                TP.ifInvalid(
                                    aFaultCode,
                                    TP.FAILED),
                                info);
                        });

                    req.defineMethod(
                        'stderr',
                        function(output, request) {

                            return aRequest.stderr(output, request);
                        });

                    req.defineMethod(
                        'stdin',
                        function() {

                            return aRequest.stdin();
                        });

                    req.defineMethod(
                        'stdout',
                        function(output, request) {

                            return aRequest.stdout(output, request);
                        });

                    aShell[TP.composeHandlerName('ShellRequest')](req);

                    return;
                } else {

                    identValue = token.value;

                    //  Make sure to convert '${X}' into '$X'
                    TP.regex.TSH_VARSUB_EXTENDED.lastIndex = 0;
                    identValue = identValue.replace(
                                    TP.regex.TSH_VARSUB_EXTENDED, '$$$1');

                    //  if the next non-whitespace token is an assignment
                    //  operator then we're looking at a possible local
                    //  variable assignment we need to rewrite. The big
                    //  question is whether we see that as an undefined
                    //  slot when we check the global scope. If the slot
                    //  is defined then we presume it's a global var.
                    if (TP.isValid(next = arr.at(i + 1))) {
                        //  skip any intervening whitespace
                        offset = 2;
                        while (next && TP.$is_whitespace(next.name)) {
                            next = arr.at(i + offset);
                            offset++;
                        }

                        //  assignment? then see if we have a previously set
                        //  global value
                        if (next && next.value === '=') {
                            if (TP.notDefined(TP.global[identValue])) {
                                //  assignment, rewrite the identifier.
                                rewrites.push(identValue);
                            }
                        }
                    }

                    result.push(identValue);
                    i += 1;
                }
            }

            break;
    }

    //  Ensure consistent context variables are in place when/if we do any
    //  eval operations for resolving command substitutions.
    $REQUEST = aRequest;
    $NODE = $REQUEST.at('cmdNode');
    $SHELL = aShell;
    $LASTREQ = $SHELL.get('previous');

    //  The current context (i.e. 'window' / 'self') that the evaluated
    //  statements will be executed in. This provides those statements with
    //  their global scope.
    $CONTEXT = aShell.getExecutionContext($REQUEST);

    //  Only in Mozilla and IE does a 'contextual eval' (i.e. one where
    //  the global/window scope is specified) take into account the current
    //  local scope (i.e. where temp variables are defined).
    //  Other browsers (Safari and Chrome) do not. Therefore, we need to
    //  make these explicitly available on the context that we're gonna
    //  invoke the eval in.
    $CONTEXT.$LASTREQ = $LASTREQ;
    $CONTEXT.$REQUEST = $REQUEST;
    $CONTEXT.$NODE = $NODE;
    $CONTEXT.$SHELL = $SHELL;
    $CONTEXT.$CONTEXT = $CONTEXT;
    $CONTEXT.$SCRIPT = $SCRIPT;
    $CONTEXT.$_ = null;

    //  complete the token processing. this may "reprocess" the initial
    //  token if it didn't signify something particular to the start of a
    //  line such as an alias or ^-based substitution.
    /* eslint-disable no-extra-parens */
    while ((token = arr[i])) {
    /* eslint-enable no-extra-parens */
        switch (token.name) {
            case 'substitution':
            case 'template':

                value = this.expandContent(token.value, $SHELL, $REQUEST);
                result.push(value);

                i += 1;
                break;

            case 'string':

                //  double-quoted strings can go through interpolation if
                //  they contain any embedded `'s or ${blah}s that aren't
                //  escaped...
                if (token.value.indexOf('"') === 0) {
                    value = this.$desugarTSH(
                        token.value.unquoted('"'),
                        aShell,
                        aRequest,
                        false);

                    //  if the desugaring failed the request we're already
                    //  done...something like `blah` exploded or a ${blah}
                    //  failed to resolve etc.
                    if (aRequest.didComplete()) {
                        return;
                    }

                    //  If the value has template constructs, then execute the
                    //  template, providing the shell's 'execution instance'
                    //  as the 'data source'.
                    if (TP.regex.HAS_ACP.test(value)) {
                        value = value.transform(
                            $SHELL.getExecutionInstance($REQUEST));
                    }

                    result.push('"', value, '"');
                } else {
                    //  single-quoted strings are exempt from interpolation
                    //  etc. so we can skip it and push directly into result
                    result.push(token.value);
                }

                i += 1;
                break;

            case 'operator':

                if (token.value === '{') {
                    //  Count when we're "in a function" so we know when we
                    //  leave.
                    if (inFunction) {
                        brackets++;
                    }
                } else if (token.value === '}') {
                    //  If we're closing a function we
                    if (inFunction) {
                        brackets--;
                        if (brackets === 0) {
                            inFunction = false;
                        }
                    }
                }

                result.push(token.value);
                i += 1;
                break;

            default:

                if (token.value === 'function') {
                    inFunction = true;
                    result.push(token.value);
                    i += 1;
                    break;
                }

                //  When we have an identifier that isn't part of a chain we
                //  presume assignments to that identifier are local scope
                //  operations. One thing we have to watch for is we only
                //  want to do this when the identifier is a true "lvalue"
                //  and not when it's being input as part of markup etc.
                if (TP.notTrue(inFunction) && TP.$is_identifier(token.name)) {
                    //  if the next non-whitespace token is an assignment
                    //  operator then we're looking at a possible local
                    //  variable assignment we may need to rewrite.
                    if (TP.isValid(next = arr.at(i + 1))) {
                        //  skip any intervening whitespace
                        offset = 2;
                        while (next && TP.$is_whitespace(next.name)) {
                            next = arr.at(i + offset);
                            offset++;
                        }

                        //  assignment? then see if we have a previously set
                        //  global value
                        if (next && next.value === '=') {
                            //  so we do have an assignment, the question
                            //  is, are we looking at a true lvalue or not?
                            j = result.getSize() - 1;
                            last = result.at(j);

                            while (last) {
                                if (last === ';') {
                                    break;
                                } else if (TP.regex.WHITESPACE.test(last)) {
                                    j--;
                                    last = result[j];
                                } else {
                                    last = null;
                                }
                            }

                            if (last === ';' &&
                                TP.notDefined(TP.global[token.value])) {
                                //  assignment, rewrite the identifier.
                                rewrites.push(token.value);
                            }
                        }
                    }
                }

                result.push(token.value);
                i += 1;

                break;
        }
    }

    //  if there were token rewrites for scope we need to reprocess the list
    //  for any of those token values now.
    if (TP.notEmpty(rewrites)) {
        result2 = TP.ac();
        len = result.length;

        for (i = 0; i < len; i++) {
            value = result[i];
            result2.push(value);
        }

        result = result2;
    }

    if (TP.isTrue(asTokens)) {
        return result;
    }

    return result.join('');
});

//  ------------------------------------------------------------------------

TP.tsh.eval.Type.defineMethod('$interpolateAlias',
function(aliasString, aTokenArray) {

    /**
     * @method $interpolateAlias
     * @summary Accepts an alias string translation and a set of command line
     *     tokens, interpolating them in such a way that tokens referenced by
     *     the alias string are consumed while remaining tokens are placed on
     *     the command line.
     * @param {String} aliasString The alias string to interpolate.
     * @param {String[]} aTokenArray An array of the tokens on the command line
     *     found after the alias.
     * @returns {String} The interpolated command line string.
     */

    var argv,
        params,
        i,
        tokens,
        token,
        next,
        value,
        result,
        name,
        arr,
        format,
        str,
        num;

    //  if the alias has no variables we can do simple concatenation
    if (!TP.regex.VARSUB.test(aliasString)) {
        return aliasString + aTokenArray.collect(
                                function(item) {

                                    return item.value;
                                }).join('');
    }

    //  if the alias has substitutions we have to tokenize it and process
    //  them as we iterate. For that to work we first have to process the
    //  rest of the command line so we know which portions are "named"
    //  parameters and which are "positional"
    argv = TP.ac();
    params = TP.hc();

    i = 0;
    tokens = [];
    token = aTokenArray[i];

    //  Step one is to collapse access paths so we don't treat things like
    //  TP.sig.Signal as a set of 5 positional parameters or fail to treat
    //  that entire reference as a value in a named parameter.
    while (token) {
        if (TP.$is_identifier(token.name)) {
            next = aTokenArray[i + 1];
            while (next &&
                    next.value !== '=' &&
                    !TP.$is_whitespace(next.name)) {
                i += 1;
                token.value += next.value;
                next = aTokenArray[i + 1];
            }
        }

        tokens.push(token);
        i += 1;
        token = aTokenArray[i];
    }

    //  Step two is to process named argument references, which means
    //  watching for a=b form and moving those into the params object as
    //  key/value.
    i = 0;
    token = tokens[i];
    while (token) {
        if (TP.$is_identifier(token.name)) {
            next = tokens[i + 1];
            if (next && next.value === '=') {
                value = tokens[i + 2];
                if (value) {
                    params.atPut(token.value,
                        value.value);
                    i += 3;
                    token = tokens[i];

                    continue;
                }
            }
        }

        if (!TP.$is_whitespace(token.name)) {
            argv.push(token.value);
        }

        i += 1;
        token = tokens[i];
    }

    //  phase two is to iterate over the alias string's token stream
    //  replacing any substitutions we can while consuming them from the
    //  params and argv containers.
    tokens = TP.$tokenize(
                    aliasString,
                    //  All of the JS operators *and* the TSH operators
                    TP.tsh.script.$tshAndJSOperators,
                    true, false, true, true);

    i = 0;
    token = tokens[i];
    result = TP.ac();

    while (token) {
        if (token.name === 'substitution' &&
            token.value.charAt(0) === '$') {
            //  Slice off the leading '${' and trailing '}'
            name = token.value.slice(2, token.value.length - 1);

            if (name.indexOf('|') !== TP.NOT_FOUND) {
                arr = name.split('|');
                name = arr.at(0);
                format = arr.at(1);
            }

            num = TP.nc(name);
            if (TP.isNumber(num)) {
                value = argv.at(num);
                if (TP.isDefined(value)) {
                    argv.atPut(num, '');

                    if (TP.notEmpty(format)) {
                        result.push(TP.format(value, format));
                    } else {
                        result.push(value);
                    }
                } else {
                    result.push(token.value);
                }
            } else {
                value = params.at(name);
                if (TP.isDefined(value)) {
                    params.removeKey(name);
                    if (TP.notEmpty(format)) {
                        result.push(TP.format(value, format));
                    } else {
                        result.push(value);
                    }
                } else {
                    result.push(token.value);
                }
            }
        } else {
            result.push(token.value);
        }

        i += 1;
        token = tokens[i];
    }

    //  final phase is to write out the final command line made up of the
    //  interpolated alias string and any unused tokens from the command
    //  line.

    //  rejoin the alias string's component parts for the first part
    str = result.join('');

    //  add on any named arguments, separated by a space.
    if (TP.notEmpty(params)) {
        str += ' ' + params.asQueryString(' ');
    }

    //  add on any remaining positional arguments
    if (TP.notEmpty(argv)) {
        str += ' ' + argv.join(' ');
    }

    return str;
});

//  ------------------------------------------------------------------------

TP.tsh.eval.Type.defineMethod('isAccessPath',
function(aTokenArray) {

    /**
     * @method isAccessPath
     * @summary Returns true if the token array provided represents what
     *     appears to be a viable access path.
     * @description An access path is a sugared form of property naming which
     *     can be converted into a call to TIBET's 'set' or 'get' functions. For
     *     example, a sequence of tokens such as 'a.b.c' can be resolved by a
     *     get call on 'a' of a.get('b.c'); Note that the access path syntax
     *     supported by the tsh:eval tag includes the proposed slicing syntax
     *     for future editions of JavaScript.
     * @param {String[]} aTokenArray A list of tokens to check.
     * @returns {Boolean}
     */

    var arr,
        token,
        i;

    //  Only worry about access path rewrites for paths with at least 2
    //  tokens, otherwise it's a standalone identifer at most.
    if (TP.isEmpty(arr = aTokenArray) || arr.getSize() < 2) {
        return false;
    }

    i = 0;
    token = arr[i];

    //  First token in the stream has to be a viable identifier, we can't
    //  have paths that start with a number, or a slice.
    if (!TP.$is_identifier(token.name)) {
        return false;
    }

    //  Second token must be a period for property access.
    i += 1;
    token = arr[i];
    if (token.value !== '.') {
        return false;
    }

    i += 1;
    token = arr[i];

    //  Remainder of the path can only have identifiers, numbers, colons,
    //  commas, minus signs or additional periods to specify property
    //  access. We won't validate that they appear in precisely the right
    //  order here, but we'll ensure that no other token values/types are
    //  found.
    while (token) {
        if (!TP.$is_identifier(token.name) &&
            token.name !== 'number' &&
            token.value !== '.' &&
            token.value !== ',' &&
            token.value !== '-' &&
            token.value !== '[' &&
            token.value !== ']' &&
            token.value !== ':') {
            return false;
        }

        i += 1;
        token = arr[i];
    }

    return true;
});

//  ------------------------------------------------------------------------

TP.tsh.eval.Type.defineMethod('cmdAddContent',
function(REQUEST$$) {

    /**
     * @method cmdAddContent
     * @summary Invoked when the receiver is being used as a sink with append
     *     semantics. In this case the object referenced by the receiver's
     *     content will have its cmdAddContent method called if it responds to
     *     one.
     * @param {TP.sig.Request} REQUEST$$ The request containing command input
     *     for the shell.
     */

    return this.cmdRunContent(REQUEST$$, TP.ADD);
});

//  ------------------------------------------------------------------------

TP.tsh.eval.Type.defineMethod('cmdFilterInput',
function(REQUEST$$) {

    /**
     * @method cmdFilterInput
     * @summary Invoked when the receiver is being used as a filter. In this
     *     case the object referenced by the receiver's content will have its
     *     cmdFilterInput method called if it responds to one.
     * @param {TP.sig.Request} REQUEST$$ The request containing command input
     *     for the shell.
     */

    return this.cmdRunContent(REQUEST$$, TP.FILTER);
});

//  ------------------------------------------------------------------------

TP.tsh.eval.Type.defineMethod('cmdGetContent',
function(REQUEST$$) {

    /**
     * @method cmdGetContent
     * @summary Executes the request's content, returning a reference to the
     *     return value of that execution. This method is invoked when the
     *     tsh:eval is used either standalone or as a data source within a TSH
     *     script.
     * @param {TP.sig.Request} REQUEST$$ The request containing command input
     *     for the shell.
     */

    //  internal to the computation process, but shouldn't be visible
    var START$$,
        END$$,
        TIME$$,
        RESULT$$,
        SCOPE$$,
        TOKENS$$,
        ERR$$,
        SCRIPT$$,
        TYPE$$,

    //  standard "special variables" we're willing to expose to scripts
        $LASTREQ,
        $REQUEST,
        $NODE,
        $SHELL,
        $CONTEXT,
        $SCRIPT;

    $REQUEST = REQUEST$$;
    $NODE = $REQUEST.at('cmdNode');
    $SHELL = $REQUEST.at('cmdShell');
    $LASTREQ = $SHELL.get('previous');

    //  tokenize the content so we can check for sugar around the various
    //  substitution and rewriting methods
    $SCRIPT = TP.nodeGetTextContent($NODE);
    if (TP.isBlank($SCRIPT)) {
        $REQUEST.complete();

        return;
    }

    //  if the command text started (originally) with an escape then literal
    //  will be set to true so we don't attempt desugaring
    if ($NODE.getAttribute('tsh:literal') !== 'true' &&
        $REQUEST.at('cmdLiteral') !== true) {
        $SCRIPT = this.$desugarTSH($SCRIPT, $SHELL, $REQUEST);

        //  certain desugaring attempts can recognize that the request is
        //  malformed and fail() it.
        if ($REQUEST.didComplete()) {
            return;
        }

        TP.nodeSetTextContent($NODE, $SCRIPT);
    }

    //  tokenize what's left so we can check for identifiers etc.
    TOKENS$$ = TP.$condenseJS(
                    $SCRIPT, false, false,
                    //  All of the JS operators *and* the TSH operators
                    TP.tsh.script.$tshAndJSOperators,
                    true, true, true);

    if (this.isAccessPath(TOKENS$$)) {

        //  first token in an access path is the object reference,
        //  the rest can be wrapped into a string access path...
        $SCRIPT = TOKENS$$[0].value +
                    '.get(TP.apc(\'' +
                    TOKENS$$.slice(2).collect(
                        function(item) {

                            return item.value;
                        }).join('') + '\'));';

        TP.nodeSetTextContent($NODE, $SCRIPT);
    }

    try {
        //  The current context (i.e. 'window' / 'self') that the evaluated
        //  statements will be executed in. This provides those statements
        //  with their global scope.
        $CONTEXT = $SHELL.getExecutionContext($REQUEST);

        //  Only in Mozilla and IE does a 'contextual eval' (i.e. one
        //  where the global/window scope is specified) take into account
        //  the current local scope (i.e. where temp variables are defined).
        //  Other browsers (Safari and Chrome) do not. Therefore, we need to
        //  make these explicitly available on the context that we're gonna
        //  invoke the eval in.
        $CONTEXT.$LASTREQ = $LASTREQ;
        $CONTEXT.$REQUEST = $REQUEST;
        $CONTEXT.$NODE = $NODE;
        $CONTEXT.$SHELL = $SHELL;
        $CONTEXT.$CONTEXT = $CONTEXT;
        $CONTEXT.$SCRIPT = $SCRIPT;
        $CONTEXT.$_ = null;

        //  eval has problems with Object and Function literals, but
        //  wrapping them in parentheses helps...

        //  Object literals
        if ($SCRIPT.charAt(0) === '{' &&
            $SCRIPT.charAt($SCRIPT.length - 1) === '}') {
            $SCRIPT = '(' + $SCRIPT + ')';
        }

        //  Function literals
        //  To keep things simpler for the regex we run the test on the script
        //  with newlines removed.
        if (TP.regex.FUNCTION_LITERAL.test($SCRIPT.replace(/\n/g, ' '))) {
            $SCRIPT = '(' + $SCRIPT + ')';
        }

        // SCRIPT$$ = TP.$condenseJS($SCRIPT, true);
        SCRIPT$$ = $SCRIPT;

        START$$ = Date.now();

        //  Grab the execution scope.
        SCOPE$$ = $SHELL.getExecutionInstance($REQUEST);

        //  Capture the 'pre eval' state of the context and place the slots from
        //  the scope onto the context.
        TP.tsh.eval.$populateContextFromScope($CONTEXT, SCOPE$$);

        //  Eval the script
        RESULT$$ = $CONTEXT.eval(SCRIPT$$);

        //  Capture the current state of the context and place the slots from
        //  the context onto the scope.
        TP.tsh.eval.$populateScopeFromContext($CONTEXT, SCOPE$$);

        END$$ = Date.now();

        TIME$$ = TP.ifInvalid($REQUEST.get('$evaltime'), 0);
        $REQUEST.set('$evaltime', TIME$$ + (END$$ - START$$));

        //  After resolving the reference, we see if the result (or it's type)
        //  can execute 'cmdGetContent'.

        if (TP.canInvoke(RESULT$$, 'cmdGetContent')) {
            RESULT$$ = RESULT$$.cmdGetContent($REQUEST);
        } else if (TP.isType(TYPE$$ = TP.type(RESULT$$))) {

            if (TP.canInvoke(TYPE$$, 'cmdGetContent')) {
                $REQUEST.atPut('cmdInstance', RESULT$$);
                RESULT$$ = TYPE$$.cmdGetContent($REQUEST);
            }
        }

        $REQUEST.complete(RESULT$$);
    } catch (e) {
        END$$ = Date.now();

        TIME$$ = TP.ifInvalid($REQUEST.get('$evaltime'), 0);
        $REQUEST.set('$evaltime', TIME$$ + (END$$ - START$$));

        if (TP.sys.cfg('tsh.ignore_eval_errors') === true) {
            //  If we're ignoring eval errors, then we just complete the request
            //  with undefined here.
            $REQUEST.complete(undefined);
        } else {
            //  NOTE we slice off the file reference at the tail
            //  since that's not accurate...we're doing
            //  interactive input here.
            ERR$$ = e.message;
            if (ERR$$.contains(' &#171; ')) {
                ERR$$ = TP.trim(ERR$$.slice(0, ERR$$.indexOf(' &#171; ')));
            }

            if (/[sS]yntax/.test(ERR$$)) {
                RESULT$$ = ERR$$ + ': ' + $SCRIPT;
            } else {
                RESULT$$ = ERR$$.endsWith('.') ? ERR$$ : ERR$$ + '.';
            }

            $REQUEST.fail(new Error(RESULT$$));
        }
    } finally {
        delete $CONTEXT.$LASTREQ;
        delete $CONTEXT.$REQUEST;
        delete $CONTEXT.$NODE;
        delete $CONTEXT.$SHELL;
        delete $CONTEXT.$CONTEXT;
        delete $CONTEXT.$SCRIPT;
        delete $CONTEXT.$_;
    }

    return;
});

//  ------------------------------------------------------------------------

TP.tsh.eval.Type.defineMethod('cmdRunContent',
function(REQUEST$$, CMDTYPE$$) {

    /**
     * @method cmdRunContent
     * @summary Invoked when the receiver is being used as either a filter or a
     *     sink in a pipe (otherwise cmdGetContent() is called).
     * @param {TP.sig.Request} REQUEST$$ The request containing command input
     *     for the shell.
     */

    //  internal to the computation process, but shouldn't be visible
    var PIPE$$,
        RESULT$$,
        TOKENS$$,
        TOKEN$$,
        QUERY$$,
        RE$$,
        ACCESS$$,
        EXEC$$,
        TYPE$$,
        CTYPE$$,
        DEREF$$,
        VAR$$,

    //  standard "special variables" we're willing to expose to scripts
        $LASTREQ,
        $REQUEST,
        $NODE,
        $TPNODE,
        $SHELL,
        $CONTEXT,
        $SCRIPT,

        cleanGlobals;

    $REQUEST = REQUEST$$;

    $SHELL = $REQUEST.at('cmdShell');
    $LASTREQ = $SHELL.$LASTREQ;
    $LASTREQ = $SHELL.get('previous');

    $NODE = $REQUEST.at('cmdNode');
    $TPNODE = TP.wrap($NODE);

    $SCRIPT = TP.trim(TP.nodeGetTextContent($NODE));
    if (TP.isBlank($SCRIPT)) {
        $REQUEST.complete();

        return;
    }

    //  The current context (i.e. 'window' / 'self') that the evaluated
    //  statements will be executed in. This provides those statements with
    //  their global scope.
    $CONTEXT = $SHELL.getExecutionContext($REQUEST);

    //  Only in Mozilla and IE does a 'contextual eval' (i.e. one where
    //  the global/window scope is specified) take into account the current
    //  local scope (i.e. where temp variables are defined).
    //  Other browsers (Safari and Chrome) do not. Therefore, we need to
    //  make these explicitly available on the context that we're gonna
    //  invoke the eval in.
    $CONTEXT.$LASTREQ = $LASTREQ;
    $CONTEXT.$REQUEST = $REQUEST;
    $CONTEXT.$NODE = $NODE;
    $CONTEXT.$SHELL = $SHELL;
    $CONTEXT.$CONTEXT = $CONTEXT;
    $CONTEXT.$SCRIPT = $SCRIPT;

    cleanGlobals = function() {

        delete $CONTEXT.$LASTREQ;
        delete $CONTEXT.$REQUEST;
        delete $CONTEXT.$NODE;
        delete $CONTEXT.$SHELL;
        delete $CONTEXT.$CONTEXT;
        delete $CONTEXT.$SCRIPT;
        delete $CONTEXT.$_;
    };

    PIPE$$ = TP.elementGetAttribute($NODE, 'tsh:pipe', true);

    //  there are a few pipe symbols which, while they are part of the
    //  overall pipe syntax, imply the current element shouldn't try to read
    //  from stdin since it's at a segment break. When that's true we clear
    //  the pipe symbol so we'll more likely drop through to a cmdGetContent
    if (TP.$is_ioend(PIPE$$)) {
        PIPE$$ = null;
    }

    //  convert to expand any aliases etc. unless literal text is forced
    if ($NODE.getAttribute('tsh:literal') !== 'true' &&
        $REQUEST.at('cmdLiteral') !== true) {
        $SCRIPT = this.$desugarTSH($SCRIPT, $SHELL, $REQUEST);

        //  certain desugaring attempts can recognize that the request is
        //  malformed and fail() it.
        if ($REQUEST.didComplete()) {
            cleanGlobals();

            return;
        }

        TP.nodeSetTextContent($NODE, $SCRIPT);
    }

    //  if the desugaring process didn't return a viable script then we
    //  have to presume that we're being sidetracked to another request
    //  (typically due to a history rewrite of some kind). In those cases
    //  we have to simply wait for any nested request to come back around
    //  and notify this request when it completes.
    if (TP.isBlank($SCRIPT)) {
        cleanGlobals();

        return;
    }

    //  first phase is to adjust the script to deal with a special case
    //  around targeting a new identifier as a sink as in 1+2 .> foo. If foo
    //  isn't already a symbol then the script won't work properly and we'll
    //  get an error about foo being undefined. If foo already exists we
    //  want to protect it with clobber/noclobber via the ! suffix.
    CTYPE$$ = CMDTYPE$$;
    switch (CMDTYPE$$) {
        case 'add':
        case 'set':

            //  tokenize what's left so we can check for identifiers etc.
            TOKENS$$ = TP.$condenseJS(
                        $SCRIPT, false, false,
                        //  All of the JS operators *and* the TSH operators
                        TP.tsh.script.$tshAndJSOperators,
                        true, true, true);

            //  one special case for sinks is when sugaring for setting a
            //  variable or property. in those cases we're looking for a strict
            //  identifier[.identifier] pattern identifying at most one target
            //  object or variable. If the length is just one identifier it's
            //  even more special.
            if (TOKENS$$.length === 1) {
                TOKEN$$ = TOKENS$$[0];
                if (TOKEN$$ && TP.$is_identifier(TOKEN$$.name)) {
                    //  could be a variable reference. if that variable isn't
                    //  set as a scoped variable then we'll do that manually,
                    //  otherwise we can get the object and test as needed.

                    //  Have to watch for '@' prefixing here. When doing a
                    //  redirection into a dereference we want to adjust the
                    //  token value to allow resolution of the variable.
                    if (TOKEN$$.value.charAt(0) === '@') {
                        TOKEN$$.value = TOKEN$$.value.slice(1);
                        //  Deal with 'shorthand' of @FOO vs. @$FOO.
                        if (TOKEN$$.value.charAt(0) !== '$') {
                            TOKEN$$.value = '$' + TOKEN$$.value;
                        }
                        DEREF$$ = true;
                        CTYPE$$ = TP.SET;
                        $SCRIPT = TOKEN$$.value;
                    }
                } else {
                    //  TODO: Had a token, but it's not an identifier?
                    void 0;
                }
            } else if (this.isAccessPath(TOKENS$$)) {
                //  Set a flag we can check later to see that this command has
                //  been rewritten as an access path, and therefore no
                //  additional work should be done after object resolution has
                //  occurred to add/set content.
                ACCESS$$ = true;

                //  first token in an access path the the object reference, the
                //  rest can be wrapped into a string access path...
                $SCRIPT = TOKENS$$[0].value + '.set(TP.apc(\'' +
                    TOKENS$$.slice(2).collect(
                        function(item) {

                            return item.value;
                        }).join('') + '\').set(\'buildout\', true), $INPUT);';
                TP.nodeSetTextContent($NODE, $SCRIPT);
            } else {
                //  fall through and let the EXEC$$ code try to invoke the
                //  proper method on the RESULT$$ of the expression.
                void 0;
            }

            break;

        default:

            //  for potential filter/transformation operations we need to
            //  look for single-token literals which indicate a sugared
            //  filter or tranformation
            if (TP.notEmpty(PIPE$$)) {
                TOKENS$$ = TP.$condenseJS(
                        $SCRIPT, false, false,
                        //  All of the JS operators *and* the TSH operators
                        TP.tsh.script.$tshAndJSOperators,
                        true, true, true);

                //  all literal token representations are single tokens

                /* eslint-disable no-extra-parens */
                if (TOKENS$$.length === 1) {
                    QUERY$$ = (PIPE$$.indexOf('?') !== TP.NOT_FOUND);
                /* eslint-enable no-extra-parens */

                    TOKEN$$ = TOKENS$$[0];
                    switch (TOKEN$$.name) {
                        case 'regexp':

                            //  the token is a regex but we don't want
                            //  to eval it...just pull it apart to call
                            //  the constructor...but we have to watch
                            //  out for embedded /'s etc...
                            RE$$ = TP.rc(
                                TOKEN$$.value.slice(1,
                                    TOKEN$$.value.lastIndexOf('/')),
                                TOKEN$$.value.slice(
                                    TOKEN$$.value.lastIndexOf('/') + 1));

                            if (TP.notValid(RE$$)) {
                                RESULT$$ = 'Invalid RegExp filter: ' +
                                    TOKEN$$.value.slice(1,
                                        TOKEN$$.value.lastIndexOf('/')) +
                                    ' ' +
                                    TOKEN$$.value.slice(
                                        TOKEN$$.value.lastIndexOf('/') + 1);

                                //  problem creating regular expression
                                //  which should have reported an error
                                $REQUEST.fail(new Error(RESULT$$));

                                cleanGlobals();

                                return;
                            }

                            //  we already know that we have a RegExp and
                            //  that it's type implements cmdFilterInput or
                            //  cmdTransformInput, so just execute that and
                            //  return.
                            $REQUEST.atPut('cmdInstance', RE$$);
                            if (QUERY$$) {
                                RegExp.cmdFilterInput($REQUEST);
                            } else {
                                RegExp.cmdTransformInput($REQUEST);
                            }

                            cleanGlobals();

                            return;

                        case 'string':

                            //  we already know that we have a String and
                            //  that it's type implements cmdFilterInput or
                            //  cmdTransformInput, so just execute that and
                            //  return.
                            $REQUEST.atPut('cmdInstance', TOKEN$$.value);
                            if (QUERY$$) {
                                String.cmdFilterInput($REQUEST);
                            } else {
                                String.cmdTransformInput($REQUEST);
                            }

                            cleanGlobals();

                            return;

                        default:

                            //  single-token content...fall through

                    }
                } else if (this.isAccessPath(TOKENS$$)) {
                    //  Set a flag we can check later to see that this
                    //  command has been rewritten as an access path, and
                    //  therefore no additional work should be done after
                    //  object resolution has occurred to add/set content.
                    ACCESS$$ = true;

                    //  first token in an access path the the object
                    //  reference, the rest can be wrapped into a string
                    //  access path...
                    $SCRIPT = TOKENS$$[0].value + '.get(TP.apc(\'' +
                        TOKENS$$.slice(2).collect(
                            function(item) {

                                return item.value;
                            }).join('') + '\'), $INPUT);';
                    TP.nodeSetTextContent($NODE, $SCRIPT);
                } else {
                    //  multi-token content...fall through
                    void 0;
                }
            } else {
                //  if we're not the target of a pipe life is easy, we're
                //  basically a "getContent" command which may/may not push
                //  our output to a downstream target.

                //  NOTE that by setting literal to true here we avoid
                //  having the getContent logic reparse/re-desugar the
                //  content.
                $REQUEST.atPut('cmdLiteral', true);

                //  NOTE also that we have to ensure a downstream
                //  nodeGetContent operation will find the updated script.
                TP.nodeSetTextContent($NODE, $SCRIPT);

                //  single-token content... we have to determine if we're the
                //  source of a piping construct of some sort (i.e. 'peek ahead'
                //  to the next command element in the pipe). If so, we have to
                //  fetch content - otherwise, we can just fall through.

                //  Note that we're looking at the pipe in the downstream
                //  segment so we want to make sure that *it* is not supposed to
                //  be doing a 'get'. If *it* is not doing a get, that means
                //  that *we* are.
                if (!$TPNODE.isLastSegment() &&
                    $TPNODE.getDownstreamSegment().getRedirectionType() !==
                                                                    TP.GET) {
                    cleanGlobals();

                    return this.cmdGetContent($REQUEST);
                }
            }

            break;
    }

    //  ---
    //  helper function
    //  ---

    EXEC$$ = function(COMPLETE$$) {

        var INPUT$$,
            LOOP$$,
            LEN$$,
            I$$,
            START$$,
            SCOPE$$,
            END$$,
            ERR$$,
            TIME$$,
            SCRIPT$$,
            FLAG$$;

        INPUT$$ = $REQUEST.stdin();
        LOOP$$ = $REQUEST.at('cmdIterate');

        LEN$$ = INPUT$$.getSize();

        //  one possible issue is when the previous command didn't write
        //  output for whatever reason, but the pipe was constructed as if
        //  the current element should expect input. when that's the case we
        //  "fake" a single null as the input data.
        if (LEN$$ === 0) {
            INPUT$$ = TP.ac(null);
            LEN$$ = 1;
        }

        //  eval has problems with Object and Function literals, but
        //  wrapping them in parentheses helps...

        //  Object literals
        if ($SCRIPT.charAt(0) === '{' &&
            $SCRIPT.charAt($SCRIPT.length - 1) === '}') {
            $SCRIPT = '(' + $SCRIPT + ')';
        }

        //  Function literals
        //  To keep things simpler for the regex we run the test on the script
        //  with newlines removed.
        if (TP.regex.FUNCTION_LITERAL.test($SCRIPT.replace(/\n/g, ' '))) {
            $SCRIPT = '(' + $SCRIPT + ')';
        }

        //  String literals - double quoted
        if ($SCRIPT.charAt(0) === '"' &&
                $SCRIPT.charAt($SCRIPT.length - 1) === '"') {
            $SCRIPT = $SHELL.resolveVariableSubstitutions($SCRIPT);
        }

        // SCRIPT$$ = TP.$condenseJS($SCRIPT, true);
        SCRIPT$$ = $SCRIPT;

        //  Tell the main Lama object that it should go ahead and process DOM
        //  mutations to the source DOM.
        if (TP.sys.hasFeature('lama')) {
            TP.bySystemId('Lama').set('shouldProcessDOMMutations', true);
        }

        FLAG$$ = TP.sys.shouldThrowExceptions();
        TP.sys.shouldThrowExceptions(true);

        /* eslint-disable no-loop-func */
        for (I$$ = 0; I$$ < LEN$$; I$$++) {

            $INPUT = INPUT$$.at(I$$);

            try {
                $REQUEST.stdout(TP.TSH_NO_VALUE);

                START$$ = Date.now();
                if (LOOP$$) {
                    if (TP.isCollection($INPUT)) {
                        //  Grab the execution scope.
                        SCOPE$$ = $SHELL.getExecutionInstance($REQUEST);
                        RESULT$$ = $INPUT.collect(
                            function(ITEM$$, INDEX$$) {
                                var result;

                                $INDEX = INDEX$$;
                                $_ = ITEM$$;

                                //  Capture the 'pre eval' state of the context
                                //  and place the slots from the scope onto the
                                //  context.
                                TP.tsh.eval.$populateContextFromScope(
                                                            $CONTEXT, SCOPE$$);

                                //  Eval the script.
                                result = $CONTEXT.eval(SCRIPT$$);

                                //  Capture the current state of the context and
                                //  place the slots from the context onto the
                                //  scope.
                                TP.tsh.eval.$populateScopeFromContext(
                                                            $CONTEXT, SCOPE$$);

                                return result;
                            });
                    } else {
                        //  splatted on non-collection...
                        $_ = $INPUT;

                        //  Grab the execution scope.
                        SCOPE$$ = $SHELL.getExecutionInstance($REQUEST);

                        //  Capture the 'pre eval' state of the context and
                        //  place the slots from the scope onto the context.
                        TP.tsh.eval.$populateContextFromScope(
                                                        $CONTEXT, SCOPE$$);

                        //  Eval the script.
                        RESULT$$ = TP.ac($CONTEXT.eval(SCRIPT$$));

                        //  Capture the current state of the context and place
                        //  the slots from the context onto the scope.
                        TP.tsh.eval.$populateScopeFromContext(
                                                        $CONTEXT, SCOPE$$);
                    }
                } else {
                    $_ = $INPUT;

                    //  Grab the execution scope.
                    SCOPE$$ = $SHELL.getExecutionInstance($REQUEST);

                    //  Capture the 'pre eval' state of the context and place
                    //  the slots from the scope onto the context.
                    TP.tsh.eval.$populateContextFromScope(
                                                    $CONTEXT, SCOPE$$);

                    //  Eval the script.
                    RESULT$$ = $CONTEXT.eval(SCRIPT$$);

                    //  Capture the current state of the context and place the
                    //  slots from the context onto the scope.
                    TP.tsh.eval.$populateScopeFromContext(
                                                    $CONTEXT, SCOPE$$);
                }
                END$$ = Date.now();

                TIME$$ = TP.ifInvalid($REQUEST.get('$evaltime'), 0);
                $REQUEST.set('$evaltime', TIME$$ + (END$$ - START$$));

                if (TP.notFalse(COMPLETE$$)) {
                    $REQUEST.complete(RESULT$$);
                }
            } catch (e) {
                END$$ = Date.now();
                TIME$$ = TP.ifInvalid($REQUEST.get('$evaltime'), 0);
                $REQUEST.set('$evaltime', TIME$$ + (END$$ - START$$));

                //  An exception was thrown - no sense in having the main Lama
                //  object process DOM mutations to the source DOM.
                if (TP.sys.hasFeature('lama')) {
                    TP.bySystemId('Lama').set('shouldProcessDOMMutations',
                                                false);
                }

                if (TP.sys.cfg('tsh.ignore_eval_errors') === true) {
                    //  If we're ignoring eval errors, then we just complete the
                    //  request with undefined here.
                    $REQUEST.complete(undefined);
                } else {
                    //  NOTE we slice off the file reference at the tail
                    //  since that's not accurate...we're doing
                    //  interactive input here.
                    ERR$$ = e.message;

                    /* eslint-disable no-extra-parens */
                    ERR$$ = (ERR$$.indexOf(':: file:') === TP.NOT_FOUND) ?
                    /* eslint-enable no-extra-parens */
                        TP.trim(ERR$$) :
                        TP.trim(ERR$$.slice(0, ERR$$.indexOf(':: file:')));
                    if (/[sS]yntax/.test(ERR$$)) {
                        RESULT$$ = ERR$$ + ': ' + $SCRIPT;
                    } else if (/missing ; before statement/.test(ERR$$)) {
                        //  Rewrites of commands/aliases etc. can sometimes
                        //  cause eval to output a useless message about a
                        //  missing ;. In those cases we want to be sure to dump
                        //  the script.
                        RESULT$$ = 'syntax error: ' + $SCRIPT;
                    } else {
                        RESULT$$ = ERR$$.endsWith('.') ? ERR$$ : ERR$$ + '.';
                    }

                    $REQUEST.fail(new Error(RESULT$$));
                }

                return;
            }
        }

        TP.sys.shouldThrowExceptions(FLAG$$);

        /* eslint-enable no-loop-func */
    };

    //  with our execution helper ready we can now process the command types
    //  and work off their results as needed.
    switch (CTYPE$$) {
        case 'var':

            //  exec once to set variable, then our work is finished
            $REQUEST.atPut('cmdIterate', false);
            EXEC$$();

            break;

        case TP.ADD:

            //  no splatting or other iterations are relevant for 'add' and
            //  we can't complete inside the exec call, we have to wait.
            $REQUEST.atPut('cmdIterate', false);
            EXEC$$(TP.ifInvalid(ACCESS$$, false));

            //  If the eval catch block triggered the request will have
            //  failed so no point in continuing.
            if ($REQUEST.didComplete()) {
                cleanGlobals();

                return;
            }

            if (TP.canInvoke(RESULT$$, 'cmdAddContent')) {
                RESULT$$ = RESULT$$.cmdAddContent($REQUEST);
            } else if (TP.isType(TYPE$$ = TP.type(RESULT$$))) {

                if (TP.canInvoke(TYPE$$, 'cmdAddContent')) {
                    $REQUEST.atPut('cmdInstance', RESULT$$);
                    RESULT$$ = TYPE$$.cmdAddContent($REQUEST);
                } else {
                    $REQUEST.fail(new Error('Invalid sink.'));
                }
            } else if (!TP.isMutable(RESULT$$)) {
                $REQUEST.fail(new Error('Non-mutable sink.'));
            } else {
                $REQUEST.fail(new Error('Missing sink.'));
            }

            break;

        case TP.FILTER:

            //  we can't complete inside the exec call, we have to wait.
            EXEC$$(TP.ifInvalid(ACCESS$$, false));

            //  If the eval catch block triggered the request will have
            //  failed so no point in continuing.
            if ($REQUEST.didComplete()) {
                cleanGlobals();

                return;
            }

            //  If the script doesn't reference either $INPUT or $_ (and hence
            //  couldn't have done "real work" on the inbound data) then we
            //  message the result object to get the content to filter.

            if (/\$INPUT/.test($SCRIPT) !== true &&
                /\$_/.test($SCRIPT) !== true) {

                if (TP.canInvoke(RESULT$$, 'cmdFilterInput')) {
                    RESULT$$ = RESULT$$.cmdFilterInput($REQUEST);
                } else if (TP.isType(TYPE$$ = TP.type(RESULT$$))) {

                    if (TP.canInvoke(TYPE$$, 'cmdFilterInput')) {
                        $REQUEST.atPut('cmdInstance', RESULT$$);
                        RESULT$$ = TYPE$$.cmdFilterInput($REQUEST);
                    } else {
                        $REQUEST.fail(new Error('Invalid pipe.'));
                    }
                } else {
                    $REQUEST.complete(RESULT$$);
                }
            } else {
                $REQUEST.complete(RESULT$$);
            }

            break;

        case TP.SET:

            //  no splatting or other iterations are relevant for 'set' and
            //  we can't complete inside the exec call, we have to wait.
            $REQUEST.atPut('cmdIterate', false);
            EXEC$$(TP.ifInvalid(ACCESS$$, false));

            //  If the eval catch block triggered the request will have
            //  failed so no point in continuing.
            if ($REQUEST.didComplete()) {
                cleanGlobals();

                return;
            }

            //  If DEREF$$ is true we're looking at a script that should resolve
            //  a variable reference. The first check here is for the ${foo}
            //  variant, which we need to adjust.
            if (TP.regex.TSH_VARIABLE.test($SCRIPT)) {
                VAR$$ = $SCRIPT.slice(1);
                if (VAR$$.charAt(0) === '{') {
                    VAR$$ = VAR$$.slice(1, -1);
                }

                if (!DEREF$$) {
                    RESULT$$ = $REQUEST.stdin().at(0);
                    $SHELL.setVariable(VAR$$, RESULT$$);
                    $REQUEST.complete(RESULT$$);

                    cleanGlobals();

                    return;
                } else {
                    RESULT$$ = $SHELL.getVariable(VAR$$);
                }
            }

            if (TP.canInvoke(RESULT$$, 'cmdSetContent')) {
                RESULT$$ = RESULT$$.cmdSetContent($REQUEST);
            } else if (TP.isType(TYPE$$ = TP.type(RESULT$$))) {

                if (TP.canInvoke(TYPE$$, 'cmdSetContent')) {
                    $REQUEST.atPut('cmdInstance', RESULT$$);
                    RESULT$$ = TYPE$$.cmdSetContent($REQUEST);
                } else {
                    $REQUEST.fail('Invalid sink.');
                }
            } else if (!TP.isMutable(RESULT$$)) {
                $REQUEST.fail('Non-mutable sink.');
            } else {
                $REQUEST.fail('Missing sink.');
            }

            break;

        case TP.TRANSFORM:

            //  we can't complete inside the exec call, we have to wait.
            EXEC$$(TP.ifInvalid(ACCESS$$, false));

            //  If the eval catch block triggered the request will have
            //  failed so no point in continuing.
            if ($REQUEST.didComplete()) {
                cleanGlobals();

                return;
            }

            //  If the script doesn't reference either $INPUT or $_ (and hence
            //  couldn't have done "real work" on the inbound data) then we
            //  message the result object to get the content to filter.

            if (/\$INPUT/.test($SCRIPT) !== true &&
                /\$_/.test($SCRIPT) !== true) {

                if (TP.canInvoke(RESULT$$, 'cmdTransformInput')) {
                    RESULT$$ = RESULT$$.cmdTransformInput($REQUEST);
                } else if (TP.isType(TYPE$$ = TP.type(RESULT$$))) {

                    if (TP.canInvoke(TYPE$$, 'cmdTransformInput')) {
                        $REQUEST.atPut('cmdInstance', RESULT$$);
                        RESULT$$ = TYPE$$.cmdTransformInput($REQUEST);
                    } else {
                        $REQUEST.fail('Invalid pipe.');
                    }
                } else {
                    $REQUEST.complete(RESULT$$);
                }
            } else {
                $REQUEST.complete(RESULT$$);
            }

            break;

        default:

            EXEC$$();
            break;
    }

    cleanGlobals();

    return;
});

//  ------------------------------------------------------------------------

TP.tsh.eval.Type.defineMethod('cmdSetContent',
function(REQUEST$$) {

    /**
     * @method cmdSetContent
     * @summary Invoked when the receiver is being used as a sink with set
     *     semantics. In this case the object referenced by the receiver's
     *     content should have its setContent method called if it responds to
     *     one.
     * @param {TP.sig.Request} REQUEST$$ The request containing command input
     *     for the shell.
     */

    return this.cmdRunContent(REQUEST$$, TP.SET);
});

//  ------------------------------------------------------------------------

TP.tsh.eval.Type.defineMethod('cmdTransformInput',
function(REQUEST$$) {

    /**
     * @method cmdTransformInput
     * @summary Invoked when the receiver is being used as a transform. In this
     *     case the object referenced by the receiver's content will its
     *     cmdTransformInput method called if it responds to one.
     * @param {TP.sig.Request} REQUEST$$ The request containing command input
     *     for the shell.
     */

    return this.cmdRunContent(REQUEST$$, TP.TRANSFORM);
});

//  ------------------------------------------------------------------------

TP.tsh.eval.Type.defineMethod('expandContent',
function(aString, aShell, aRequest) {

    /**
     * @method expandContent
     * @summary Expands content contained in the supplied source string using
     *     the provided shell.
     * @description Content expansion consists of expanding any command
     *     substitutions (content inside of `...` constructs), templates, and
     *     shell variables contained in the content.
     * @param {String} aString The source string to expand content in.
     * @param {TP.shell.Shell} aShell The shell instance.
     * @param {TP.sig.Request} aRequest The request containing command input for
     *     the shell.
     * @returns {String} The source string with the content expanded.
     */

    var result,

        SCRIPT$$,
        SCOPE$$,
        RESULT$$,

    //  standard "special variables" we're willing to expose to scripts
        $LASTREQ,
        $REQUEST,
        $NODE,
        $SHELL,
        $CONTEXT,
        $SCRIPT,

        err,
        flag,
        value,
        sourcevars,

        wasCommandSubstitution;

    //  If the string is single-quoted we do nothing.
    if (aString.unquoted().quoted('\'') === aString) {
        return aString;
    }

    //  Don't expand variable names. We leave them for later resolution.
    if (TP.regex.TSH_VARIABLE.test(aString)) {
        return aString;
    }

    //  There is an order of operation here when expanding content:

    //  1. Process template substitutions
    //  2. Process variable substitutions
    //  3. Process command substitutions

    //  set up some common variables
    $REQUEST = aRequest;
    $SHELL = aShell;

    //  set up our output buffer
    result = TP.ac();

    //  ---
    //  Step 1: Process template substitutions
    //  ---

    value = aString;

    //  If the value is a template, then we use template transformation. We do
    //  *not* resolve variable substitutions using the normal mechanism before
    //  transforming the template or otherwise we'll have literal values in the
    //  template, which won't work. Instead, we supply the shell's 'execution
    //  instance' to the templating engine as a 'data source'.
    if (TP.regex.HAS_ACP.test(value)) {

        //  Since templating treats '$' variables specially (i.e. $INDEX,
        //  etc.), and all shell variables have a leading '$', we need to
        //  pull out the names of the variables in our String and supply
        //  them as a set of names that the transformation engine should
        //  treat as 'normal'.

        //  First, we convert '${X}' into '$X'
        TP.regex.TSH_VARSUB_EXTENDED.lastIndex = 0;
        value = value.replace(TP.regex.TSH_VARSUB_EXTENDED, '$$$1');

        //  Next, extract the source variables, either in '$X' or used-to-be
        //  '${X}' form into an Array where they are all normalized to '$X'.
        sourcevars = TP.ac();
        TP.regex.TSH_VARSUB_EXTRACT.lastIndex = 0;
        TP.regex.TSH_VARSUB_EXTRACT.performWith(
                function(wholeMatch, varName) {
                    sourcevars.push('$' + varName);
                }, value);

        //  Do the transformation with the execution instance as the data source.
        value = value.transform(
            $SHELL.getExecutionInstance($REQUEST),
            TP.hc('sourcevars', sourcevars));
    } else {
        TP.regex.TSH_VARSUB_EXTENDED.lastIndex = 0;
        value = value.replace(TP.regex.TSH_VARSUB_EXTENDED, '$$$1');
    }

    //  Make sure to detect command substitutions *before* trying to resolve
    //  variables substitutions
    wasCommandSubstitution = false;

    //  If the value starts with a backtick ('`'), then it's a command
    //  substitution, so flag it as such and trim off the leading and trailing
    //  '`'.
    if (value.indexOf('`') === 0) {
        wasCommandSubstitution = true;
        value = value.slice(1, -1);
    }

    //  ---
    //  Step 2: Process variable substitutions
    //  ---

    $SCRIPT = $SHELL.resolveVariableSubstitutions(value);

    //  ---
    //  Step 3: Process command substitutions
    //  ---

    //  command substitution...effectively inlining result data where the
    //  command text is positioned.
    if (wasCommandSubstitution === true) {

        if (TP.notTrue(TP.ifKeyInvalid(aRequest, 'cmdBuildGUI', false)) &&
            TP.notTrue(TP.ifKeyInvalid(aRequest, 'cmdAllowSubs', false))) {
            aRequest.fail(
                new Error(
                TP.sc(TP.join(
                        'Security violation. Attempt to use',
                        ' command substitution outside of',
                        ' interactive mode.'))));

            return;
        }

        //  If 'value' matches shell 'dereference sugar' (i.e. '@foo'), then we
        //  have to strip the leading '@'.
        if (TP.regex.TSH_DEREF_SUGAR.test(value)) {
            value = value.slice(1);
        }

        $SCRIPT = value;

        //  Ensure consistent context variables are in place when/if we do any
        //  eval operations for resolving command substitutions.
        $NODE = $REQUEST.at('cmdNode');
        $LASTREQ = $SHELL.get('previous');

        //  The current context (i.e. 'window' / 'self') that the evaluated
        //  statements will be executed in. This provides those statements with
        //  their global scope.
        $CONTEXT = aShell.getExecutionContext($REQUEST);

        //  Only in Mozilla and IE does a 'contextual eval' (i.e. one where
        //  the global/window scope is specified) take into account the current
        //  local scope (i.e. where temp variables are defined).
        //  Other browsers (Safari and Chrome) do not. Therefore, we need to
        //  make these explicitly available on the context that we're gonna
        //  invoke the eval in.
        $CONTEXT.$LASTREQ = $LASTREQ;
        $CONTEXT.$REQUEST = $REQUEST;
        $CONTEXT.$NODE = $NODE;
        $CONTEXT.$SHELL = $SHELL;
        $CONTEXT.$CONTEXT = $CONTEXT;
        $CONTEXT.$SCRIPT = $SCRIPT;
        $CONTEXT.$_ = null;

        try {
            flag = TP.sys.shouldThrowExceptions();
            TP.sys.shouldThrowExceptions(true);

            //  Refresh the context's script reference after any substitutions
            //  so any internal reference to it will reflect what's being eval'd.
            $CONTEXT.$SCRIPT = $SCRIPT;

            //  eval has problems with Object and Function literals, but
            //  wrapping them in parentheses helps...

            //  Object literals
            if ($SCRIPT.charAt(0) === '{' &&
                $SCRIPT.charAt($SCRIPT.length - 1) === '}') {
                $SCRIPT = '(' + $SCRIPT + ')';
            }

            //  Function literals
            //  To keep things simpler for the regex we run the test on the
            //  script with newlines removed.
            if (TP.regex.FUNCTION_LITERAL.test($SCRIPT.replace(/\n/g, ' '))) {
                $SCRIPT = '(' + $SCRIPT + ')';
            }

            // $SCRIPT = TP.$condenseJS($SCRIPT, true);
            SCRIPT$$ = $SCRIPT;

            //  Grab the execution scope.
            SCOPE$$ = $SHELL.getExecutionInstance($REQUEST);

            //  Capture the 'pre eval' state of the context and place the slots
            //  from the scope onto the context.
            TP.tsh.eval.$populateContextFromScope($CONTEXT, SCOPE$$);

            //  Eval the script.
            RESULT$$ = $CONTEXT.eval(SCRIPT$$);

            //  Capture the current state of the context and place the slots
            //  from the context onto the scope.
            TP.tsh.eval.$populateScopeFromContext($CONTEXT, SCOPE$$);
        } catch (e) {

            if (TP.sys.cfg('tsh.ignore_eval_errors') === true) {
                //  Note that if we're ignoring eval errors, then we just return
                //  the 'undefined' *String* here (if we just return undefined,
                //  then the engine waits for another request because it thinks
                //  this one hasn't finished and is part of a pipe or
                //  something).
                RESULT$$ = 'undefined';
            } else {
                //  NOTE we slice off the file reference at the tail since that's
                //  not accurate...we're doing interactive input here.
                err = e.message;

                /* eslint-disable no-extra-parens */
                err = (err.indexOf(':: file:') === TP.NOT_FOUND) ?
                /* eslint-enable no-extra-parens */
                    TP.trim(err) :
                    TP.trim(err.slice(0, err.indexOf(':: file:')));
                err = err.endsWith('.') ? err : err + '.';

                $REQUEST.fail(
                    new Error(
                    TP.join(
                        TP.sc('Command substitution `'),
                        aString.slice(1, -1),
                        TP.sc('` failed: '),
                        err)));
            }
        } finally {
            //  Reset our flags...
            TP.sys.shouldThrowExceptions(flag);
        }

        //  if the catch block failed the request we're done.
        if (aRequest.didComplete()) {
            return;
        }

        result.push(RESULT$$);

    } else {
        result.push($SCRIPT);
    }

    return result.join('');
});

//  ------------------------------------------------------------------------

TP.tsh.eval.Type.defineMethod('$populateContextFromScope',
function(context, scope) {

    /**
     * @method $populateContextFromScope
     * @summary Populates the supplied context from the supplied scope. This is
     *     typically called before a shell 'eval' operation.
     * @param {Object} context The context that the eval will happen in.
     * @param {Object} scope The scope object that 'global' properties will be
     *     placed in when code is eval'ed.
     * @returns {TP.meta.tsh.eval} The receiver.
     */

    var originalKeys,
        originalKeySet;

    //  Grab the keys that currently exist on the context and make a Set from
    //  them.
    originalKeys = Object.keys(context);
    originalKeySet = new Set(originalKeys);

    this.$set('$originalContextKeySet', originalKeySet, false);

    //  Grab the keys from the scope, iterate over them and wire them over to
    //  the context.
    TP.keys(scope).forEach(
        function(aKey) {
            context[aKey] = scope[aKey];
        });

    return this;
});

//  ------------------------------------------------------------------------

TP.tsh.eval.Type.defineMethod('$populateScopeFromContext',
function(context, scope) {

    /**
     * @method $populateScopeFromContext
     * @summary Populates the supplied scope from the supplied context. This is
     *     typically called before a shell 'eval' operation.
     * @param {Object} context The context that the eval will happen in.
     * @param {Object} scope The scope object that 'global' properties will be
     *     placed in when code is eval'ed.
     * @returns {TP.meta.tsh.eval} The receiver.
     */

    var originalKeySet,

        currentKeys,
        diffKeys;

    //  This will be the set of keys that the context originally had before we
    //  put slots from the scope onto it.
    originalKeySet = this.$get('$originalContextKeySet');

    //  Grab the set of keys that are currently on the context and filter them
    //  against the set of keys that were there before we put slots from the
    //  scope onto it. This will result in the set of keys that should be copied
    //  over to the scope and deleted from the context.
    currentKeys = Object.keys(context);
    diffKeys = currentKeys.filter(
                function(aKey) {
                    return !originalKeySet.has(aKey);
                });

    diffKeys.forEach(
        function(aKey) {
            var val;

            //  Grab the value for the key from the context and set it onto the
            //  scope.
            val = context[aKey];
            scope.atPut(aKey, val);

            //  Delete the key from the context. Note that context here is
            //  normally the global object.
            delete context[aKey];
        });

    return this;
});

//  ------------------------------------------------------------------------

TP.tsh.eval.Type.defineMethod('tshExecute',
function(aRequest) {

    /**
     * @method tshExecute
     * @summary Responds to requests by the TSH to execute. The tsh:eval tag
     *     doesn't process in this fashion, it can only be invoked as part of a
     *     tsh:script tag's execution so this method raises an
     *     TP.sig.InvalidOperation exception.
     * @param {TP.sig.Request} aRequest The request to be processed.
     * @exception TP.sig.InvalidOperation
     * @returns {TP.sig.Request|Number} The request or a TSH shell loop control
     *     constant which controls how the outer TSH processing loop should
     *     continue. Common values are TP.CONTINUE, TP.DESCEND, and TP.BREAK.
     */

    this.raise('TP.sig.InvalidOperation');

    return TP.BREAK;
});

//  ------------------------------------------------------------------------
//  end
//  ========================================================================
